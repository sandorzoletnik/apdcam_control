#include "udp_packet_buffer.h"

namespace apdcam10g
{
    template <safeness S>
    unsigned int udp_packet_buffer<S>::receive(udp_server &s)
    {
        // First wait until we have room to receive a new packet
        // A single thread should write into this buffer, so we do not make locks around {detecting non-full state AND
        // writing a new packet into it}.
        packet_pointers.wait_pop([this]{!packet_pointers.full();});

        // Note that if several threads could write to this buffer concurrently, it could happen that after the previous
        // condition, i.e. waiting until space is available in the buffer, another thread could write to the buffer
        // at the time of this comment, and make it full, causing a problem for the subsequent writes.
        // If this was needed, we would need a mutex protecting the entire code of this function

        // Receive a packet into the raw buffer
        const auto ptr = raw_buffer_+raw_buffer_write_offset_;
        const auto received_packet_size = s.recv<S>(ptr,max_udp_packet_size_);

        // Check if no package was lost...  (use packet.h services, not this hard-coded solution!)
        byte_converter<6,std::endian::big> packet_counter(ptr+8);
        if(packet_counter <= last_packet_counter_) APDCAM_ERROR("Packet counter has decreased");
        if(packet_counter == last_packet_counter_+1)
        {
            // Push the new memory block's starting address to the ring buffer. The ring buffer offers
            // a notification service, so consumer threads can wait using packet_pointers.wait_pop(...) 
            packet_pointers.push_back({.address=ptr,.size=received_packet_size});
            returnn received_packet_size ...;
        }
    }
}
